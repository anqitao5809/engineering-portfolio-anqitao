# Abstract
## Design Brief
Blindness and severe vision impairment affect millions of people worldwide. According to the American Foundation for the Blind, 50.18 million adult Americans reported they either have trouble seeing, even when wearing glasses or contact lenses, or that they are blind or unable to see at all. This makes everyday tasks such as navigation, reading, and interacting with the environment a significant challenge. There is a critical need for innovative solutions that can help these individuals navigate their environments more easily. 

Our end user, particularly, experiences a high degree of astigmatism and hyperopia, causing her to have blurry vision at all distances, which makes reading small text a constant struggle, especially when identifying critical information on medicine bottles, such as names, dosages, and instructions. Many medical labels are still printed in small, inaccessible fonts that are unfriendly to visually impaired individuals, increasing the risk of medication errors.

## Solution Description
This is a handheld device with a built-in RFID reader that plays audio information when it detects RFID stickers attached to objects. It is mainly used for prescription labels to help users, especially those with vision impairments, identify their medications. Each RFID sticker can be linked to a custom audio message using the device’s record function. Users can record their own MP3 files for each sticker, and the device will play the recorded message whenever that specific sticker is scanned. For a product functionality logic diagram, please refer to figure 1.

# Design Iteration
In the duration of our project, we use Arduino to achieve the intended feature. We have changed the specific model one time in order to shrink in size. However we realize the other model, which is Arduino pro micro, does have the feature that we needed. Arduino pro micro is missing features like SPI, which also means that the SD card, which we needed, can not be used on Arduino pro micro. Arduino Pro micro does indeed have the feature, it’s just wired to the led indicator light from the processor. Our first proposed solution is to solder off the led light and hook up a wire to use this feature hidden behind the led. This approach does have its risks, and also on the forum there’s saying that some significant alteration of the Arduino code is needed, which will add time, complexity, and uncertainty to our project. This is not what it is intended to be used for. We eventually switched back to what we originally were using, Arduino UNO. 

Initially, we are using another audio module for recording, SD isn’t in our original design. The audio module is supposed to come with built in storage. The initial design in electrical contains a button for start recording mode, rfid module to read rfid tags, and the main arduino Uno for processing user requests. However, the audio module breaks three times, perhaps due to electrical wiring fault with the button. On the last module we tried, it was broken out of the box. The audio module comes with its own library. We have struggled with connecting with the audio module. It took us a week or so to figure out that in their documentation, they have write the port config in softwareserial incorrectly. They have written it so that the RX and TX port is reversed. After the Arduino boots up, it will keep showing that the audio module is not connected to the Arduino. Our original design functions like the following. User can press a button to start “write mode”, and that will use the rfid module to read the current rfid user is holding near the product, and it will start recording on the audio module for a specific duration. After recording is finished, it will be stored in the build in storage that comes with the audio module. However, we don’t have direct access to the build in storage, the audio module library will only return a filename that is corresponding to the audio module. The filename is in the format that contains a number that increases every time you record an audio. This brings a challenge of how to identify the audio corresponding to the rfid tag. After some research, I decided to use EEPROM, the build in persistent storage for Arduino. This way, we can avoid the trouble of adding a SD card to store information and keep things small, light, and efficient. I created a custom data structure that will correspond the rfid with the filename and put them into EEPROM. Even though EEPROM has limited size that will probably be the limiting factor when a user has a lot of rfid tag, we decided that it will be hard to hit the limit and proceed with this approach. 

After the audio module broke three times, we decided to move on to a new approach. We decide to use an amplifier as the recorder with a speaker to play audio. This is largely made possible because there’s a existing arduino library that does the heavy lifting with audio relating things, eg. encoding, decoding, frequency, volume. This new solution that we find provides the same functionality as before, but with more reliability and control because we are using more basic hardware. However this does come with downside, Arduino has poor processing power and little ram which makes it hard to process high definition audio. Also, the amplifier we are using can only record poor audio quality. The speaker is also not loud enough. There’s certainly room for improvement on the hardware choices. 

This solution uses an external library called TMRpcm that will process all the audio waves into readable files. Then, it will use the Arduino SD library to store files into the SD card. EEPROM is removed, and replaced with a simple naming organization. The new process includes using the rfid module to read the rfid tag, start recording with an amplifier using the TMRpcm library, and save the recording in the SD card with the name of rfid_ID.wav.

One time, I set the sampling rate to be high in the library configuration with the purpose of testing its limit. This directly results in the whole program in Arduino freezing with no signs of what the error is. The whole program just stops at some point and becomes unresponsive. I believe the cause of that is too much memory is being used and the critical hardware part can’t use memory because all of them are being occupied with recording that is processing. 

## Electronics
On the preliminary device function logic diagram(figure 1), I’ve been working on RFID tag detection so far. The electronics I used include the RDM6300, an RFID reader module that operates at 125kHz and is designed for reading EM4100-compatible RFID tags. It works by generating a magnetic field using an external copper wire loop as an antenna to detect nearby RFID tags.

After finishing the project deliverables with my teammates, starting from 2/10, I began searching for the optimal electronics for each part. This process took me two days, and I decided to use the RDM6300, an RFID reader already provided to us by our adviser, Mr. Hwang. I looked through several online tutorials, including Michael Schoeffler’s, which provided wiring diagrams and sample code(by Michael Schoeffler).
Additionally, I looked for Arduino-compatible modules for the voice recording section in our function diagram, hoping to replace our existing SD card + MP3 player + microphone module setup, which increased both cost and building complexity. According to my teammate Joe Zhao, different audio writing speeds across these modules might also cause synchronization issues.
I initially considered the ISD1820, a voice recorder module capable of recording and playing short audio clips using a built-in microphone. However, since the ISD1820 can only store and replay one audio file at a time, it did not meet our requirement of storing and accessing multiple files.
My teammate Joe then found the Fermion Voice Recorder module, which features a built-in 16MB memory, an integrated audio player, and a recording function. Upon further research, I reviewed its datasheet and confirmed that it supports multiple stored audio files, which can be accessed via Arduino code. We determined that this integrated recorder module was the best fit for our project. Thus, on 2/14, we finalized our parts shopping list.

From 2/12 to 2/14, I wired the RDM6300 to an Arduino Uno R3 according to Schoeffler’s tutorial and modified the source code to display each RFID tag’s unique identifier and state. (figure 2)

However, after uploading the code to the Uno R3, the expected output did not appear in the Serial Monitor. I double-checked all wiring connections and changed the original serial pins from (6,8) to (4,5) as a troubleshooting step, but this did not resolve the issue. Next, I replaced the RDM6300 and copper wire loop with a new setup while keeping the same code and wiring. This time, the Serial Monitor successfully printed out information when an RFID tag was detected (Video.1)

During this troubleshooting process, I also noticed that when the copper wire loop was placed on top of a conductive surface, the RFID detection failed. I concluded that if the current does not flow properly within the loop, the magnetic field cannot form, preventing it from detecting changes caused by nearby RFID tags.


During the second phase of the project, my focus shifted from RFID tag detection to building, testing, and iterating the rest of the electronics setup, including power management, data memory, Input/Output components.

From 2/21 to 3/18, alongside researching the RFID stickers and other forms of user inputs, I focused on making the Fermion Voice Recorder module(DFR0745) work, as my team had decided it’s multi-segment audio recording and playing functionalities can save us much room compared to using a combination of SD card, speaker, and microphone. 

I soldered the Fermion module’s pins and created a test circuit based on the datasheet (figure 3)
Using sample code, I attempted to initialize the module in the Arduino IDE, but it failed to respond as the debugging lines indicated that the code is stuck in the initialization While loop.. I double-checked the wiring and tried various fixes, including reassigning RX/TX pins and formatting the module. Despite several efforts, including resoldering the VIN pin and switching Arduino boards, the module still failed to initialize. We suspected that the module was either defective or had been shorted during a reflash. 
After switching to a second module we ordered from before, I was able to successfully initialize it with the exact same wiring and code, which proved that our previous suspicion was correct. I ran a basic “play” test on the second Fermion module, which played a recording I had previously inputted using a USB-C. 
However, while Joe was testing the circuit later, he created a button circuit and connected it to the arduino board. Upon pressing the button, the Fermion module stopped working. I later found out that the button was not properly grounded therefore might have been sending excessive current into the module and caused defections. I attempted to troubleshoot the module the next day, only to find all indications of successful initialization(LEDs and Debugging lines in the Serial Monitor on Arduino IDE) missing like the first one.

Since the module was very difficult to work with, as there are nearly no available instructions other than a datasheet provided by the manufacturer, my team decided to switch to our original plan with external memory cards and audio I/O components, which have more online tutorials and references.

3/19-4/9: Since the fermion module didn’t function as expected, our team collectively decided on another plan. I began searching for the exact electronics we needed to order, gathering information about ISD1820, APR33A3 and other voice recording modules(these modules unfortunately lack customization or don’t support multi-segment recording). Eventually, I was able to collect all necessary modules that would achieve the functionalities we aim at: an SD card reader, RFID reader, MAX4466 microphone, speaker, and components for power(battery, charging module TP4056, and flip switches) from our adviser. 

By 3/24, I had finished wiring the entire circuit on a breadboard by referring to a guide from an Instructables Spy Bug tutorial, which helped me prepare the prototype for testing by Joe. (figure 4)
 Around this time, I decided to switch from the Arduino Pro Micro to the Arduino Uno due to compatibility issues. Specifically, I discovered that the Pro Micro lacked a broken-out chip select (CS) pin necessary for using the micro SD card module(figure 5)(figure 6)
 
After testing each section (RFID detection, button input, audio recording and memory writing) of code individually, I confirmed the pin number with joe and soldered components to header pins, which were inserted into the arduino board to provide more stable connections than jumper wires in our final prototype. During this time, I also coordinated with Aaron to adapt the physical holder for the copper wire loop and make more space for all the electronics.

On 4/1, I began focusing on power management. I learned how to use the TP4056 USB-C charging module, which I soldered to a lithium rechargeable battery. I tested the voltage and confirmed circuit continuity. However, I soon realized the TP4056 module only outputs 3.9V, which was insufficient for our board. I replaced it with a 5V-outputting charging module provided by Mr. Hwang and tested the new setup using an LED. (figure 7).

I then discovered that the pin placement on the charging module was poorly designed. Pins that could easily short were placed adjacent to each other—specifically, the 5V output pin was positioned directly next to the battery ground pin—posing a potential electrical hazard. After discussing the issue with my teammates, we decided to switch to using a 9V AC-DC adapter to power the Arduino. Although this setup requires the device to be plugged into an outlet, it ensures a consistent power supply and significantly reduces safety risks(figure 8)

For users concerned with portability, a 9V rechargeable battery with an integrated, fully enclosed charging module is also an option. This alternative provides both safety and the convenience of using the device in different areas of the home (figure 9)

For a more detailed iteration log for electronics, see appendix Table.1, lines documented by Anqi Tao.

## CAD
2/20/25
Initially, our design was centered around a glove. However, we realized that gloves are not common wearables and may potentially cause inconveniences for visually impaired individuals. Therefore, we decided to change the design from a glove to a watch. A watch is more universal, can be worn daily, and can also incorporate time-telling functions. Despite these advantages, we encountered a challenge: the small size of a watch may not fit all the necessary electronics, such as memory cards, speakers, and Arduino boards. (Figure 17)

As we explored alternatives, we discussed changing the watch to another form of wearable or even a stationary device. This led me to CAD a jar for the RFID reader using Fusion 360. The jar design allows the RFID reader to detect the RFID tag inside and read aloud its contents. During this process, I faced difficulties creating a locking mechanism using the thread feature on Fusion 360. To overcome this issue, I researched online and found a simple locking mechanism that I plan to implement later. For now, I decided to use threads for screwing the lid onto the jar to move forward with iterating our 3D printed vessel for the electronics to scan the RFID stickers. (Figure 17)

Eventually, we finalized our decision to create a handheld/mobile product in stick form, similar to the sticks used at TSA checkpoints. This design was chosen, because it can house all the components, and making it a wearable would be too heavy and inconvenient. Using Fusion 360, I created an almost exact replica of a TSA security stick. To ensure the components are securely enclosed, we decided to use screws to shut the two parts together. (Figure 18)

I researched a technique from an Instructables winner who used a soldering iron to press an M4 nut insert into a 3D printed hole, allowing a screw to be inserted and close the two components. I plan to use this technique in the near future. Additionally, I will need to create a window in the design to keep the coil of the RFID reader in place, which will be completed within the next three weeks. (Figure 19)
Overall, my progress includes evolving my design from a glove to a watch, exploring different forms of wearables, CADing a jar for the RFID reader, and finalizing a stick form design for the handheld/mobile product. My next steps involve implementing the discovered locking mechanism, creating a window for the RFID reader coil, and ensuring all components are securely enclosed in the final design. (Figure 20)

4/10/25
After successfully 3D printing the bottom component of the SENSE prototype, there came many obstacles along the way including trying to find the precise measurements for the threaded holes for the screws, creating a window for the vessel/holder, creating handlebar for the vessel, and overall integrating and navigating around the electronic components essential to the prototype’s functionality.

As for the first prototype (bottom part of the holder), I made substantial progress despite these obstacles. I carefully executed the threaded holes required for six distinct screw placements and incorporated a designated space for the RFID coil. This was accompanied by a practical window to accommodate the wires, creating seamless connectivity. Moreover, I designed a dedicated compartment to house a keyboard switch for the record button. Through each iteration, I learned to refine both the technical and aesthetic elements of the prototype, paving the way for future enhancements and innovations. (Figure 21)

A problem that I encountered was getting the wires from the RFID coil through the window into the inside of the bottom part of the prototype. Although the RFID coil fit into place, the window for the wires was adjusted, so that it could extend into the holder. (Figure 22)

In relation to the first prototype (bottom part of holder), the keyboard switch fit into the compartment, however, I had to redesign the encasing. Due to the missing place for an opening for the wires to get through to the switch and connect to the module, I simply extruded a hole outwards to solve this issue. (Figure 23)

To determine the correct threading for the screw holes in my prototype, I created three test cylinders with different thread specifications. First, I designed and modeled the cylinders in Fusion, ensuring the external dimensions remained constant to focus on the threading variable. I threaded the first cylinder with ANSI M3x0.5 specifications as a baseline. The second cylinder was adjusted to an ANSI M3x0.35 thread size. For the third cylinder, I applied the ANSI M3.5x0.6 threading, adhering to standardized specifications for class 6H. After conducting fitment tests with the M3 counterbore screws corresponding to each cylinder’s threading, I found the M3.5 threading to be optimal, confirming that ANSI M3.5x0.6 specifications best worked with screwing into the threading with ease. (Figure 24)

One simple iteration I made was adjusting the screw threading for all the different holes, since I had forgotten to change the threading for every screw hole when I 3D printed the bottom part of the prototype. (Figure 24)

After 3D printing the top part of the prototype (Figure 14), I encountered several challenges that required careful adjustments. One of the first issues was resizing the button for the keyboard switch to ensure it fit properly and functioned seamlessly within the design. Additionally, for the bottom part of the prototype, I had to determine the best location for a charging port and an on/off switch, ensuring they were ergonomically positioned and easy to access without compromising the overall structure. Another key modification involved adjusting the diameter of the head of the counterbore hole. During testing with the second prototype, I found that the existing size made it somewhat difficult to screw in, which affected the ease of assembly. To resolve this, I would have to increase the diameter of the counterbore (top part) hole slightly for the third prototype. (Figure 25)

The third prototype consists of six of the same hole threadings for size M3 screws, an area for a charging port and an on/off switch, a record button, handlebar grip, a designated area for the RFID coil and tag, and space inside of the holder for electronic components. (Figure 26)

5/22/25
SENSE (Figure 11) (Figure 12) (Figure 13) went through over 2,000 iterations in our CAD model (Figure 14) (Figure 15) (Figure 16), evolving with every version. Initially, we based our concept around a glove (Figure 17) but soon realized the difficulties of ensuring a proper fit for different users. Taking Mr. Hwang's suggestions into account, we explored the idea of a watch (Figure 17) that could be worn daily. However, incorporating RFID readers and tags into a compact watch proved impractical due to space limitations for essential electronics. This led us to reevaluate our approach and eventually settle on a TSA scanner-inspired design (Figure 20), which allowed for all necessary components while maintaining ease of use. In the early stages, we planned for a button to control recording and audio playback, alongside a designated RFID reader compartment. After creating the first prototype (Figure 21), several modifications were made, including shifting the button from the center of the top component of the device to the handlebar area for better ergonomics. The RFID reader holder also underwent multiple redesigns to optimize space for scanning RFID tags (Figure 22). The button compartment required adjustments to ensure smooth wiring to the keyboard switch (Figure 23), and later, we replaced the keyboard switch with a standard square Arduino button for greater reliability, as we were not able to get the keyboard switch to program well. Throughout the process, we refined screw hole diameters and screw types to achieve secure and efficient assembly. The handlebar was extended around the entire device rather than being limited to the top component, prioritizing both ergonomics and usability. As we approached the final CAD prototype (Figure 27), we finalized the placement of the charging port to allow proper wiring and accessibility. Additionally, a dedicated button for recording and audio playback was changed to a position on the side of the device to enhance functionality.Throughout the entire CAD development process, we continuously refined the fit and arrangement of components to ensure SENSE was a stable, functional, and accessible solution, staying true to our original design specifications:

Customer Needs: Customers, like severely visually impaired people or blind people, need a way to read everyday text such as medicine labels and signs. The device must effectively convert text into clear audio information for the user. The solution should cater to people who have difficulty reading Braille or people who don’t always have access to Braille.
Performance: The device should be able to scan a wide range of printed materials.The product must be compact and portable. Battery life should be over 5 hours.
Target Cost: customers will pay at most $200 for the product
Size and Weight: Design should be no bigger than 1dm3, and less than 0.3kg, easy to carry around and install
Aesthetics: should be simple looking
Materials: durable and safe PLA, Plastic
Safety, Legal, and Ethical Issues: should not have sharp edges or any electronics exposed in the air. 
Ergonomics: Design should be no bigger than 1dm3, and less than 0.3kg, easy to carry around and install for blind people
Operating Environment: Outdoor/Indoor, away from damp areas as electricity is involved.
Environmental Impact and Sustainability: Uses biodegradable materials.(PLA) Customers should be able to reuse products after their first purchase.
Product life: 5 years.
Durability and Maintenance: 5 Years. Products should use parts replaceable for easier maintenance.
